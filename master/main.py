# generated by fastapi-codegen:
#   filename:  client-master_openapi.json
#   timestamp: 2025-09-17T03:29:58+00:00

from __future__ import annotations

import argparse
import uuid
from enum import Enum
from fastapi import BackgroundTasks, FastAPI, status
from fastapi.responses import JSONResponse
from pathlib import Path
from urllib.parse import urlparse, urlunparse
from .models import (
    HealthCheck,
    JobCancelJobIdPostResponse,
    JobResultJobIdGetResponse,
    JobStatusJobIdGetResponse,
    JobSubmitPostRequest,
    JobSubmitPostResponse,
)


def handle_master(args: argparse.Namespace) -> None:
    raise NotImplementedError


class STATUS(str, Enum):
    STARTED = "STARTED"
    RUNNING = "RUNNING"
    STOPPED = "STOPPED"
    INACTIVE = "DONE"


class Master:
    def __init__(self):
        self.job_status = {}
        self.workers = {}

    # This was made with GPT, it resolves the URL so it can find the folder while no using an abs path.
    def resolve_path(self, data_url):
        file_url = urlparse(str(data_url))
        host = file_url.netloc or "localhost"
        raw_path = file_url.path.lstrip("/")  # prevent leading slash confusion

        if host in ("localhost", "127.0.0.1"):
            # Resolve against current working dir
            return Path(raw_path).resolve()
        else:
            raise ValueError(f"Remote host {host} not supported yet")

    def create_job(self):
        job_id = str(uuid.uuid4())
        self.job_status[job_id] = STATUS.STARTED

        return job_id

    def register_worker(self, worker_url):
        self.workers.append(worker_url)

    def begin_job(self, body: JobSubmitPostRequest, job_id: str):

        self.job_status[job_id] = STATUS.RUNNING

        # Checking the specified directory and counting the files inside.
        try:
            dir_path = self.resolve_path(body.data_url)

            files = [f for f in dir_path.iterdir() if f.is_file()]
            file_count = len(files)

            # According to the source, "Without this conversion, your API would return system-dependent paths (like /home/user/test_folder/file1.txt),
            # which might not match the file:// style your client expects."
            file_urls = [
                urlunparse(("file", "", str(f.resolve()), "", "", "")) for f in files
            ]

            for file_url in file_urls:
                print(file_url)

            print(f"Number of files in directory: {file_count}")

        except Exception as e:
            self.job_status[job_id] = STATUS.STOPPED
            print(e)


master_instance = Master()
app = FastAPI(
    title="MapReduce Master API",
    version="0.2.0",
)


@app.post("/worker/register")
def register_worker():
    """
    Register a worker machine
    """

    pass


@app.get(
    "/",
    response_model=HealthCheck,
)
def health_check() -> HealthCheck:
    """
    Health Check
    """
    return HealthCheck(status="ok")


@app.post("/job/cancel/{job_id}", response_model=JobCancelJobIdPostResponse)
def cancel_job(job_id: str) -> JobCancelJobIdPostResponse:
    """
    Cancel a running job
    """
    pass


@app.get("/job/result/{job_id}", response_model=JobResultJobIdGetResponse)
def get_job_result(job_id: str) -> JobResultJobIdGetResponse:
    """
    Get job result
    """
    pass


@app.get("/job/status/{job_id}", response_model=JobStatusJobIdGetResponse)
def get_job_status(self, job_id: str) -> JobStatusJobIdGetResponse:

    status = master_instance.job_status.get(job_id)


@app.post(
    "/job/submit",
    response_model=None,
    responses={
        "201": {
            "model": JobSubmitPostResponse,
            "description": "Job accepted",
        },
        "400": {"description": "Invalid job submission"},
    },
)
def submit_job(
    body: JobSubmitPostRequest, background_tasks: BackgroundTasks
) -> JSONResponse:
    """
    Submit a new job
    """
    job_id = master_instance.create_job()

    background_tasks.add_task(master_instance.begin_job, body, job_id)

    return JSONResponse(
        content=JobSubmitPostResponse(
            job_id=job_id, status="Job started successfully"
        ).model_dump(),
        status_code=status.HTTP_201_CREATED,
    )
