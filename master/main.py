# generated by fastapi-codegen:
#   filename:  client-master_openapi.json
#   timestamp: 2025-09-17T03:29:58+00:00

from __future__ import annotations

import argparse
import uuid
from enum import Enum
from fastapi import BackgroundTasks, FastAPI, Request, status
from fastapi.responses import JSONResponse
from pathlib import Path
from urllib.parse import urlparse, urlunparse
from .models import (
    HealthCheck,
    JobCancelJobIdPostResponse,
    JobResultJobIdGetResponse,
    JobStatusJobIdGetResponse,
    JobSubmitPostRequest,
    JobSubmitPostResponse,
    # RegisterWorkerRequest,
    # RegisterWorkerResponse,
)


def handle_master(args: argparse.Namespace) -> None:
    raise NotImplementedError


class STATUS(str, Enum):
    STARTED = "STARTED"
    RUNNING = "RUNNING"
    STOPPED = "STOPPED"
    INACTIVE = "DONE"
    BUSY = "BUSY"
    AVAILABLE = "AVAILABLE"


class Master:
    def __init__(self):
        self.jobs = {}
        self.workers = {}

    # This was made with GPT, it resolves the URL so it can find the folder while no using an abs path.
    def resolve_path(self, data_url):
        file_url = urlparse(str(data_url))
        host = file_url.netloc or "localhost"
        raw_path = file_url.path.lstrip("/")  # prevent leading slash confusion

        if host in ("localhost", "127.0.0.1"):
            # Resolve against current working dir
            return Path(raw_path).resolve()
        else:
            raise ValueError(f"Remote host {host} not supported yet")

    def create_job(self):
        job_id = str(uuid.uuid4())
        self.jobs[job_id] = {'status':STATUS.STARTED,'Errors': None }

        return job_id

    def register_worker(self, worker_url,worker_type):
        if worker_url in self.workers:
            return "worker already exists"
        
        self.workers[worker_url] = {
            "status": STATUS.AVAILABLE, 
            "type": worker_type,
        }
            
        return "succesfully created"

    def assign_job_to_worker(self, file_url: str) -> bool:
        """
        Assigns a file to an available worker and communicates with it through OpenAPI.
        Returns True if assignment was successful, False otherwise.
        """
        available_workers = [url for url, info in self.workers.items() if info["status"] == STATUS.AVAILABLE]
        if not available_workers:
            return False
            
        # Simple round-robin assignment
        worker_url = available_workers[0]


    def begin_job(self, body: JobSubmitPostRequest, job_id: str):

        self.jobs[job_id]["status"] = STATUS.RUNNING

        # Checking the specified directory and counting the files inside.
        try:
            dir_path = self.resolve_path(body.data_url)

            files = [f for f in dir_path.iterdir() if f.is_file()]
            file_count = len(files)

            # According to the source, "Without this conversion, your API would return system-dependent paths (like /home/user/test_folder/file1.txt),
            # which might not match the file:// style your client expects."
            file_urls = [
                urlunparse(("file", "", str(f.resolve()), "", "", "")) for f in files
            ]

            # Try to assign each file to an available worker
            for file_url in file_urls:
                #worker_response = self.assign_job_to_worker(file_url)
                pass
                

        except Exception as e:
            self.job_status[job_id] = STATUS.STOPPED
            print(e)


master_instance = Master()
app = FastAPI(
    title="MapReduce Master API",
    version="0.2.0",
)

# @app.post("/worker/register")
# async def register_worker(request: Request,  body: RegisterWorkerRequest):
#     """
#     Register a worker machine.
#     The worker's listening port should be sent as a query parameter.
#     Example: POST /worker/register?port=8001
#     """
#     worker_url = f"http://{request.client.host}:{request.client.port}"
#     worker_type = body.worker_type
#     response = master_instance.register_worker(worker_url,worker_type)

#     return JSONResponse(content=RegisterWorkerResponse(
#         worker_url=worker_url,
#         worker_status= response
#     ))
    


@app.get(
    "/",
    response_model=HealthCheck,
)
def health_check() -> HealthCheck:
    """
    Health Check
    """
    return HealthCheck(status="ok")


@app.post("/job/cancel/{job_id}", response_model=JobCancelJobIdPostResponse)
def cancel_job(job_id: str) -> JobCancelJobIdPostResponse:
    """
    Cancel a running job
    """
    pass


@app.get("/job/result/{job_id}", response_model=JobResultJobIdGetResponse)
def get_job_result(job_id: str) -> JobResultJobIdGetResponse:
    """
    Get job result
    """
    pass


@app.get("/job/status/{job_id}", response_model=JobStatusJobIdGetResponse)
def get_job_status(self, job_id: str) -> JobStatusJobIdGetResponse:

    status = master_instance.job_status.get(job_id)


@app.post(
    "/job/submit",
    response_model=None,
    responses={
        "201": {
            "model": JobSubmitPostResponse,
            "description": "Job accepted",
        },
        "400": {"description": "Invalid job submission"},
    },
)
def submit_job(
    body: JobSubmitPostRequest, background_tasks: BackgroundTasks
) -> JSONResponse:
    """
    Submit a new job
    """
    job_id = master_instance.create_job()

    background_tasks.add_task(master_instance.begin_job, body, job_id)

    return JSONResponse(
        content=JobSubmitPostResponse(
            job_id=job_id, 
            status="Job started successfully",
        ).model_dump(),
        status_code=status.HTTP_201_CREATED,
    )
